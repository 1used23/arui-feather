{"version":3,"sources":["input-autocomplete/input-autocomplete.jsx"],"names":["InputAutocomplete","state","value","inputFocused","menuFocused","popupStyles","highlightedItem","blurTimeout","inputFocusTimeout","popup","setTarget","input","getBoxNode","updatePopupStyles","getNode","clearTimeout","cn","Input","props","undefined","ref","className","focused","onChange","handleChange","onFocus","handleInputFocus","onBlur","handleInputBlur","onKeyDown","handleKeyDown","width","renderPopup","formattedOptionsList","options","formatOptionsList","opened","length","size","name","handleClickOutside","directions","minWidth","maxWidth","menu","handleItemCheck","handleHighlightedItem","handleMenuFocus","handleMenuBlur","handleMenuKeyDown","checkedItemsValues","checkedItemValue","checkedItem","getCheckedOption","newValue","text","onItemSelect","updateValueOnItemSelect","setState","setTimeout","focus","event","solveFocused","persist","onClickOutside","which","DOWN_ARROW","preventDefault","posX","window","pageXOffset","posY","pageYOffset","scrollTo","ESCAPE","blur","UP_ARROW","syncKeyboardNavigationWithScroll","currentFocused","focusedElement","document","activeElement","newState","getControl","contains","newFocused","map","option","type","content","title","key","description","result","find","findInGroup","inputWidth","getBoundingClientRect","equalPopupWidth","element","container","getInnerNode","correction","offsetHeight","offsetTop","scrollTop","targetY","duration","Component","propTypes","arrayOf","shape","oneOf","string","node","array","disabled","bool","func","defaultProps"],"mappings":"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","file":"input-autocomplete.js","sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/* eslint react/prop-types: 0 */\n\nimport { autobind } from 'core-decorators';\nimport React from 'react';\nimport Type from 'prop-types';\n\nimport Input from '../input/input';\nimport Menu from '../menu/menu';\nimport Popup from '../popup/popup';\nimport ResizeSensor from '../resize-sensor/resize-sensor';\n\nimport cn from '../cn';\nimport keyboardCode from '../lib/keyboard-code';\nimport performance from '../performance';\nimport scrollTo from '../lib/scroll-to';\nimport { SCROLL_TO_NORMAL_DURATION } from '../vars';\n\n/**\n * Компонент поля для ввода с автокомплитом.\n *\n * @extends Input\n */\n@cn('input', Input)\n@performance(true)\nclass InputAutocomplete extends React.Component {\n    static propTypes = {\n        ...Input.propTypes,\n        /** Список вариантов выбора */\n        options: Type.arrayOf(Type.shape({\n            /** Тип списка вариантов */\n            type: Type.oneOf(['item', 'group']),\n            /** Уникальное значение, которое будет отправлено на сервер, если вариант выбран */\n            value: Type.string,\n            /** Отображение варианта */\n            description: Type.node,\n            /** Текст, который должен быть записан в текстовое поле при выборе варианта */\n            text: Type.string,\n            /** Список вариантов, только для type='group' */\n            content: Type.array\n        })),\n        /** Управление возможностью изменения атрибута компонента, установка соответствующего класса-модификатора для оформления */\n        disabled: Type.bool,\n        /** Управление видимостью выпадающего списка */\n        opened: Type.bool,\n        /** Размер компонента */\n        size: Type.oneOf(['s', 'm', 'l', 'xl']),\n        /** Управление возможностью компонента занимать всю ширину родителя */\n        width: Type.oneOf(['default', 'available']),\n        /** Ширинa выпадающего списка равна ширине инпута */\n        equalPopupWidth: Type.bool,\n        /** Определяет нужно или нет обновлять значение текстового поля при выборе варианта */\n        updateValueOnItemSelect: Type.bool,\n        /** Направления, в которые может открываться попап компонента */\n        directions: Type.arrayOf(Type.oneOf([\n            'top-left', 'top-center', 'top-right', 'left-top', 'left-center', 'left-bottom', 'right-top',\n            'right-center', 'right-bottom', 'bottom-left', 'bottom-center', 'bottom-right'\n        ])),\n        /** Обработчик выбора пункта в выпадающем меню */\n        onItemSelect: Type.func\n    };\n\n    static defaultProps = {\n        disabled: false,\n        size: 'm',\n        width: 'default',\n        options: [],\n        updateValueOnItemSelect: true,\n        directions: ['bottom-left', 'bottom-right', 'top-left', 'top-right'],\n        equalPopupWidth: false\n    };\n\n    state = {\n        value: '',\n        inputFocused: false,\n        menuFocused: false,\n        popupStyles: {},\n        highlightedItem: null\n    };\n\n    /**\n     * @type {Input}\n     */\n    input;\n\n    /**\n     * @type {Popup}\n     */\n    popup;\n\n    /**\n     * @type {Menu}\n     */\n    menu;\n\n    /**\n     * @type {Number}\n     */\n    blurTimeout = null;\n\n    /**\n     * @type {Number}\n     */\n    inputFocusTimeout = null;\n\n    componentDidMount() {\n        if (this.popup) {\n            this.popup.setTarget(this.input.getBoxNode());\n        }\n\n        this.updatePopupStyles();\n    }\n\n    componentDidUpdate() {\n        if (this.popup) {\n            this.popup.setTarget(this.input.getNode());\n        }\n        this.updatePopupStyles();\n    }\n\n    componentWillUnmount() {\n        if (this.blurTimeout) {\n            clearTimeout(this.blurTimeout);\n            this.blurTimeout = null;\n        }\n\n        if (this.inputFocusTimeout) {\n            clearTimeout(this.inputFocusTimeout);\n            this.inputFocusTimeout = null;\n        }\n    }\n\n    render(cn, Input) {\n        let value = this.props.value !== undefined ? this.props.value : this.state.value;\n\n        let props = {\n            ...this.props,\n            ref: (input) => { this.input = input; },\n            className: cn({\n                focused: this.state.inputFocused || this.state.menuFocused,\n                'has-autocomplete': true\n            }),\n            value,\n            onChange: this.handleChange,\n            onFocus: this.handleInputFocus,\n            onBlur: this.handleInputBlur,\n            onKeyDown: this.handleKeyDown\n        };\n\n        return (\n            <div\n                className={ cn('autocomplete-case', { width: this.props.width }) }\n            >\n                <Input { ...props } />\n                { this.renderPopup(cn) }\n            </div>\n        );\n    }\n\n    renderPopup(cn) {\n        let formattedOptionsList = this.props.options\n            ? this.formatOptionsList(this.props.options)\n            : [];\n\n        let opened = this.props.opened !== undefined\n            ? this.props.opened\n            : this.state.inputFocused || this.state.menuFocused;\n\n        if (this.props.options.length === 0) {\n            this.popup = null;\n            return null;\n        }\n\n        return [\n            <ResizeSensor onResize={ this.updatePopupStyles } key='popup-sensor' />,\n            <Popup\n                className={ cn('popup') }\n                size={ this.props.size }\n                ref={ (popup) => { this.popup = popup; } }\n                for={ this.props.name }\n                visible={ opened }\n                autoclosable={ true }\n                onClickOutside={ this.handleClickOutside }\n                target='anchor'\n                directions={ this.props.directions }\n                height='adaptive'\n                padded={ false }\n                minWidth={ this.state.popupStyles.minWidth }\n                maxWidth={ this.state.popupStyles.maxWidth }\n                key='popup'\n            >\n                <Menu\n                    ref={ (menu) => { this.menu = menu; } }\n                    className={ cn('menu') }\n                    size={ this.props.size }\n                    mode='radio-check'\n                    content={ formattedOptionsList }\n                    checkedItems={ [] }\n                    onItemCheck={ this.handleItemCheck }\n                    autoFocusFirstItem={ true }\n                    highlightedItem={ this.state.highlightedItem }\n                    onHighlightItem={ this.handleHighlightedItem }\n                    onFocus={ this.handleMenuFocus }\n                    onBlur={ this.handleMenuBlur }\n                    onKeyDown={ this.handleMenuKeyDown }\n                />\n            </Popup>\n        ];\n    }\n\n    @autobind\n    handleItemCheck(checkedItemsValues) {\n        let checkedItemValue = checkedItemsValues.length ? checkedItemsValues[0] : this.state.checkedItemValue;\n        let checkedItem = this.getCheckedOption(this.props.options, checkedItemValue);\n\n        let newValue = checkedItem\n            ? (checkedItem.text || checkedItem.value)\n            : this.state.value;\n\n        if (this.props.onItemSelect) {\n            this.props.onItemSelect(checkedItem);\n        }\n\n        if (this.props.updateValueOnItemSelect) {\n            this.setState({ value: newValue });\n\n            if (this.props.onChange) {\n                this.props.onChange(newValue);\n            }\n        }\n\n        if (this.inputFocusTimeout) {\n            clearTimeout(this.inputFocusTimeout);\n        }\n\n        this.inputFocusTimeout = setTimeout(() => this.input.focus(), 0);\n    }\n\n    @autobind\n    handleChange(value) {\n        this.setState({ value });\n\n        if (this.props.onChange) {\n            this.props.onChange(value);\n        }\n    }\n\n    @autobind\n    handleInputFocus(event) {\n        if (this.blurTimeout) {\n            clearTimeout(this.blurTimeout);\n            this.blurTimeout = null;\n        }\n\n        this.solveFocused(event);\n\n        this.setState({\n            highlightedItem: null\n        });\n    }\n\n    @autobind\n    handleInputBlur(event) {\n        if (this.blurTimeout) {\n            clearTimeout(this.blurTimeout);\n        }\n\n        event.persist();\n\n        this.blurTimeout = setTimeout(() => {\n            this.solveFocused(event);\n            this.blurTimeout = null;\n        }, 0);\n    }\n\n    @autobind\n    handleMenuFocus(event) {\n        if (this.blurTimeout) {\n            clearTimeout(this.blurTimeout);\n            this.blurTimeout = null;\n        }\n\n        this.solveFocused(event);\n    }\n\n    @autobind\n    handleMenuBlur(event) {\n        if (this.blurTimeout) {\n            clearTimeout(this.blurTimeout);\n        }\n\n        event.persist();\n\n        this.blurTimeout = setTimeout(() => {\n            this.solveFocused(event);\n            this.blurTimeout = null;\n        }, 0);\n    }\n\n    @autobind\n    handleClickOutside() {\n        if (this.props.onClickOutside) {\n            this.props.onClickOutside();\n        }\n    }\n\n    @autobind\n    handleKeyDown(event) {\n        switch (event.which) {\n            case keyboardCode.DOWN_ARROW: {\n                event.preventDefault();\n\n                let posX = window.pageXOffset;\n                let posY = window.pageYOffset;\n\n                if (this.menu) {\n                    this.menu.focus();\n                }\n\n                window.scrollTo(posX, posY);\n\n                break;\n            }\n\n            case keyboardCode.ESCAPE: {\n                this.input.blur();\n                break;\n            }\n        }\n\n        if (this.props.onKeyDown) {\n            this.props.onKeyDown(event);\n        }\n    }\n\n    @autobind\n    handleHighlightedItem(highlightedItem) {\n        this.setState({\n            highlightedItem\n        });\n    }\n\n    @autobind\n    handleMenuKeyDown(event, highlightedItem) {\n        switch (event.which) {\n            case keyboardCode.DOWN_ARROW:\n            case keyboardCode.UP_ARROW:\n                event.preventDefault();\n                this.syncKeyboardNavigationWithScroll(highlightedItem);\n                break;\n\n            case keyboardCode.ESCAPE:\n                this.input.focus();\n                break;\n        }\n\n        if (this.props.onKeyDown) {\n            this.props.onKeyDown(event);\n        }\n    }\n\n    /**\n     * Устанавливает фокус на поле ввода.\n     *\n     * @public\n     */\n    focus() {\n        this.input.focus();\n    }\n\n    /**\n     * Убирает фокус с поля ввода.\n     *\n     * @public\n     */\n    blur() {\n        this.input.blur();\n    }\n\n    /**\n     * Скроллит страницу до поля ввода.\n     *\n     * @public\n     */\n    scrollTo() {\n        this.input.scrollTo();\n    }\n\n    /**\n     * Определяет является ли весь компонент в фокусе на событиях onFocus/onBlur.\n     *\n     * @param {SyntheticEvent} event Событие focus/blur, которое будет проброшено в обработчик onFocus/onBlur\n     */\n    solveFocused(event) {\n        let currentFocused = this.state.inputFocused || this.state.menuFocused;\n\n        let focusedElement = document.activeElement;\n\n        let newState = {\n            inputFocused: (focusedElement === this.input.getControl()),\n            menuFocused: this.menu\n                ? (this.menu.getNode() === focusedElement || this.menu.getNode().contains(focusedElement))\n                : false\n        };\n\n        let newFocused = newState.inputFocused || newState.menuFocused;\n\n        if (currentFocused !== newFocused) {\n            if (newFocused) {\n                if (this.props.onFocus) {\n                    this.props.onFocus(event);\n                }\n            } else if (this.props.onBlur) {\n                this.props.onBlur(event);\n            }\n        }\n\n        this.setState(newState);\n    }\n\n    formatOptionsList(options) {\n        return (\n            options.map((option) => {\n                if (option.type === 'group' && !!option.content) {\n                    let content = this.formatOptionsList(option.content);\n\n                    return ({\n                        type: 'group',\n                        title: option.title,\n                        content\n                    });\n                }\n\n                return ({\n                    key: option.key || option.value,\n                    value: option.value,\n                    content: option.description || option.value\n                });\n            })\n        );\n    }\n\n    getCheckedOption(options, value) {\n        let result = null;\n\n        options.find((option) => {\n            if (option.type === 'group' && !!option.content) {\n                let findInGroup = this.getCheckedOption(option.content, value);\n                if (findInGroup) {\n                    result = findInGroup;\n                    return true;\n                }\n            } else if (option.value === value) {\n                result = option;\n                return true;\n            }\n\n            return false;\n        });\n\n        return result;\n    }\n\n    @autobind\n    updatePopupStyles() {\n        let input = this.input.getNode();\n        let inputWidth = input.getBoundingClientRect().width;\n        let popupStyles = { minWidth: inputWidth };\n\n        if (this.props.equalPopupWidth) {\n            popupStyles.maxWidth = inputWidth;\n        }\n\n        this.setState({\n            popupStyles\n        });\n    }\n\n    /**\n     * @param {MenuItem} highlightedItem Выбранный пункт меню\n     */\n    syncKeyboardNavigationWithScroll(highlightedItem) {\n        let element = highlightedItem.getNode();\n        let container = this.popup.getInnerNode();\n        let correction = element.offsetHeight;\n\n        if (element.offsetTop + correction > container.scrollTop + container.offsetHeight) {\n            scrollTo({\n                container,\n                targetY: element.offsetTop,\n                duration: SCROLL_TO_NORMAL_DURATION\n            });\n        } else if (element.offsetTop < container.scrollTop) {\n            scrollTo({\n                container,\n                targetY: (element.offsetTop - container.offsetHeight) + correction,\n                duration: SCROLL_TO_NORMAL_DURATION\n            });\n        }\n    }\n}\n\nexport default InputAutocomplete;\n"]}